<!DOCTYPE html>
<html lang="en">
  <head>
    <title>p2.js Canvas mousejoint example</title>
    <meta charset="utf-8">
    <script src="../../build/p2.js"></script>
  </head>
  <body>

    <!-- The canvas, where we draw stuff -->
    <canvas width="600" height="400" id="myCanvas"></canvas>

    <script>
      var canvas, ctx, w, h, world, boxBody, planeBody, mouseConstraint, mouseBody;
      var scaleX = 50, scaleY = -50;

      var start = [0,0];
      var end = [0,0];

      init();
      animate();

      function init(){

        // Init canvas
        canvas = document.getElementById("myCanvas");
        w = canvas.width;
        h = canvas.height;

        ctx = canvas.getContext("2d");
        ctx.lineWidth = 0.05;

        // Init p2.js
        world = new p2.World({
          gravity: [0, 0]
        });

        // Add a box
        boxShape = new p2.Rectangle(2,1);
        boxBody = new p2.Body({
          mass:1,
          position:[0,2],
          angularVelocity:1
        });
        boxBody.addShape(boxShape);
        world.addBody(boxBody);

        // Add a circle
        circleShape = new p2.Circle(1);
        circleBody = new p2.Body({
          mass:1,
          position:[0,-1],
          angularVelocity:1
        });
        circleBody.addShape(circleShape);
        world.addBody(circleBody);

        // Add a plane
        planeShape = new p2.Plane();
        planeBody = new p2.Body({
          position: [3,0],
          angle: Math.PI / 3
        });
        planeBody.addShape(planeShape);
        world.addBody(planeBody);

        // Create a body for the cursor
        mouseBody = new p2.Body();
        world.addBody(mouseBody);

        canvas.addEventListener('mousedown', function(event){

          // Convert the canvas coordinate to physics coordinates
          var position = getPhysicsCoord(event);

          // Check if the cursor is inside the box
          var hitBodies = world.hitTest(position, [boxBody]);

          if(hitBodies.length){

            // Move the mouse body to the cursor position
            mouseBody.position[0] = position[0];
            mouseBody.position[1] = position[1];

            // Create a RevoluteConstraint.
            // This constraint lets the bodies rotate around a common point
            mouseConstraint = new p2.RevoluteConstraint(mouseBody, boxBody, {
              worldPivot: position,
              collideConnected:false
            });
            world.addConstraint(mouseConstraint);
          }
        });

        // Sync the mouse body to be at the cursor position
        canvas.addEventListener('mousemove', function(event){
          var position = getPhysicsCoord(event);
          mouseBody.position[0] = position[0];
          mouseBody.position[1] = position[1];
        });

        // Remove the mouse constraint on mouse up
        canvas.addEventListener('mouseup', function(event){
          world.removeConstraint(mouseConstraint);
          mouseConstraint = null;
        });
      }

      // Convert a canvas coordiante to physics coordinate
      function getPhysicsCoord(mouseEvent){
          var rect = canvas.getBoundingClientRect();
          var x = mouseEvent.clientX - rect.left;
          var y = mouseEvent.clientY - rect.top;

          x = (x - w / 2) / scaleX;
          y = (y - h / 2) / scaleY;

          return [x, y];
      }

      function drawbox(){
        ctx.beginPath();
        var x = boxBody.position[0],
            y = boxBody.position[1];
        ctx.save();
        ctx.translate(x, y);        // Translate to the center of the box
        ctx.rotate(boxBody.angle);  // Rotate to the box body frame
        ctx.rect(-boxShape.width/2, -boxShape.height/2, boxShape.width, boxShape.height);
        ctx.stroke();
        ctx.restore();
      }

      function drawPlane(){
        ctx.beginPath();
        var x = planeBody.position[0],
            y = planeBody.position[1];
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(planeBody.angle);
        ctx.moveTo(-100, 0);
        ctx.lineTo(100, 0);
        ctx.stroke();
        ctx.restore();
      }

      function drawCircle(){
        ctx.beginPath();
        var x = circleBody.position[0],
            y = circleBody.position[1];
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(circleBody.angle);
        ctx.arc(0,0,circleShape.radius,0,2*Math.PI);
        ctx.stroke();
        ctx.restore();
      }

      function drawRays(){
        start[0] = -3;
        start[1] = Math.sin(world.time) * 4;
        end[0] = 5;
        end[1] = Math.sin(world.time);

        var result = new p2.RaycastResult();
        world.raycastClosest(start, end, {}, result);

        // Draw hit point
        if(result.hasHit){
          ctx.beginPath();
          ctx.arc(result.hitPointWorld[0],result.hitPointWorld[1],0.1,0,2*Math.PI);
          ctx.stroke();
        }

        // Draw line
        ctx.beginPath();
        ctx.moveTo(start[0], start[1]);
        ctx.lineTo(end[0], end[1]);
        ctx.stroke();

        // Draw hit normal
        ctx.beginPath();
        ctx.moveTo(result.hitPointWorld[0], result.hitPointWorld[1]);
        ctx.lineTo(
          result.hitPointWorld[0] + result.hitNormalWorld[0],
          result.hitPointWorld[1] + result.hitNormalWorld[1]
        );
        ctx.stroke();
      }

      function render(){
        // Clear the canvas
        ctx.clearRect(0,0,w,h);

        // Transform the canvas
        ctx.save();
        ctx.translate(w/2, h/2); // Translate to the center
        ctx.scale(scaleX, scaleY);

        // Draw all bodies
        drawbox();
        drawPlane();
        drawCircle();
        drawRays();

        // Restore transform
        ctx.restore();
      }

      // Animation loop
      function animate(){
        requestAnimationFrame(animate);

        // Move physics bodies forward in time
        world.step(1/60);

        // Render scene
        render();
      }

   </script>

  </body>
</html>
